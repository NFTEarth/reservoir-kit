/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/attributes/v1': {
    get: operations['getAttributesV1']
  }
  '/collection/v1': {
    /** Get detailed information about a single collection, including real-time stats. */
    get: operations['getCollectionV1']
  }
  '/collections/v1': {
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    get: operations['getCollectionsV1']
  }
  '/collections/v2': {
    /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
    get: operations['getCollectionsV2']
  }
  '/orders/v1': {
    /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
    get: operations['getOrdersV1']
    post: operations['postOrdersV1']
  }
  '/owners/v1': {
    /** Get owners with various filters applied, and a summary of their ownership. Useful for exploring top owners in a collection or attribute. */
    get: operations['getOwnersV1']
  }
  '/sales/v1': {
    /** Get recent sales for a contract or token. */
    get: operations['getSalesV1']
  }
  '/sales/v2': {
    /** Get recent sales for a contract or token. */
    get: operations['getSalesV2']
  }
  '/sales/v3': {
    /** Note: this API is returns rich metadata, and has advanced filters, so is only designed for small amounts of recent sales. If you want access to sales in bulk, use the `Aggregator > Bulk Sales` API. */
    get: operations['getSalesV3']
  }
  '/stats/v1': {
    get: operations['getStatsV1']
  }
  '/tokens/v1': {
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    get: operations['getTokensV1']
  }
  '/tokens/v2': {
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    get: operations['getTokensV2']
  }
  '/tokens/v3': {
    /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
    get: operations['getTokensV3']
  }
  '/transfers/v1': {
    /** Get recent transfers for a contract or token. */
    get: operations['getTransfersV1']
  }
  '/transfers/v2': {
    /** Get recent transfers for a contract or token. */
    get: operations['getTransfersV2']
  }
  '/collections/{collectionOrSlug}/v1': {
    /** Get detailed information about a single collection, including real-time stats. */
    get: operations['getCollectionsCollectionorslugV1']
  }
  '/execute/bid/v1': {
    get: operations['getExecuteBidV1']
  }
  '/execute/buy/v1': {
    get: operations['getExecuteBuyV1']
  }
  '/execute/cancel/v1': {
    get: operations['getExecuteCancelV1']
  }
  '/execute/list/v1': {
    get: operations['getExecuteListV1']
  }
  '/execute/sell/v1': {
    get: operations['getExecuteSellV1']
  }
  '/liquidity/users/v1': {
    /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
    get: operations['getLiquidityUsersV1']
  }
  '/orders/all/v1': {
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    get: operations['getOrdersAllV1']
  }
  '/orders/asks/v1': {
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    get: operations['getOrdersAsksV1']
  }
  '/orders/bids/v1': {
    /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
    get: operations['getOrdersBidsV1']
  }
  '/orders/executed/v1': {
    get: operations['getOrdersExecutedV1']
  }
  '/sales/bulk/v1': {
    /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Sales` endpoint */
    get: operations['getSalesBulkV1']
  }
  '/tokens/details/v1': {
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    get: operations['getTokensDetailsV1']
  }
  '/tokens/details/v2': {
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    get: operations['getTokensDetailsV2']
  }
  '/tokens/details/v3': {
    /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
    get: operations['getTokensDetailsV3']
  }
  '/tokens/floor/v1': {
    /** This API will return the best price of every token in a collection that is currently on sale */
    get: operations['getTokensFloorV1']
  }
  '/collections/{collection}/top-bids/v1': {
    /** When users are placing collection or trait bids, this API can be used to show them where the bid is in the context of other bids, and how many tokens it will be the top bid for. */
    get: operations['getCollectionsCollectionTopbidsV1']
  }
  '/collections/{collection}/attributes/v1': {
    get: operations['getCollectionsCollectionAttributesV1']
  }
  '/events/tokens/floor-ask/v1': {
    /**
     * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
     *
     * There are multiple event types, which describe what caused the change in price:
     *
     * - `new-order` > new listing at a lower price
     *
     * - `expiry` > the previous best listing expired
     *
     * - `sale` > the previous best listing was filled
     *
     * - `cancel` > the previous best listing was cancelled
     *
     * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
     *
     * - `approval-change` > the best listing was invalidated due to revoked approval
     *
     * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
     *
     * - `bootstrap` > initial loading of data, so that all tokens have a price associated
     *
     * Some considerations to keep in mind
     *
     * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
     *
     * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
     */
    get: operations['getEventsTokensFlooraskV1']
  }
  '/events/tokens/floor-ask/v2': {
    /**
     * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
     *
     * There are multiple event types, which describe what caused the change in price:
     *
     * - `new-order` > new listing at a lower price
     *
     * - `expiry` > the previous best listing expired
     *
     * - `sale` > the previous best listing was filled
     *
     * - `cancel` > the previous best listing was cancelled
     *
     * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
     *
     * - `approval-change` > the best listing was invalidated due to revoked approval
     *
     * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
     *
     * - `bootstrap` > initial loading of data, so that all tokens have a price associated
     *
     * Some considerations to keep in mind
     *
     * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
     *
     * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
     */
    get: operations['getEventsTokensFlooraskV2']
  }
  '/users/{user}/tokens/v2': {
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    get: operations['getUsersUserTokensV2']
  }
  '/users/{user}/positions/v1': {
    /** Get aggregate user liquidity, grouped by collection. Useful for showing a summary of liquidity being provided (orders made). */
    get: operations['getUsersUserPositionsV1']
  }
  '/users/{user}/collections/v1': {
    /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
    get: operations['getUsersUserCollectionsV1']
  }
  '/users/{user}/tokens/v1': {
    /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
    get: operations['getUsersUserTokensV1']
  }
  '/collections/{collection}/attributes/all/v1': {
    get: operations['getCollectionsCollectionAttributesAllV1']
  }
  '/collections/{collection}/attributes/static/v1': {
    get: operations['getCollectionsCollectionAttributesStaticV1']
  }
  '/collections/{collection}/attributes/explore/v1': {
    get: operations['getCollectionsCollectionAttributesExploreV1']
  }
  '/api-keys': {
    /**
     * The optional API key can be used in every route, by setting it as a request header **x-api-key**.
     *
     * <a href='https://reservoirprotocol.github.io/docs/api/hosted-api'>Learn more</a> about API Keys and Rate Limiting
     */
    post: operations['postApikeys']
  }
  '/admin/fix-blocks': {
    post: operations['postAdminFixblocks']
  }
  '/admin/fix-cache': {
    post: operations['postAdminFixcache']
  }
  '/admin/fix-orders': {
    post: operations['postAdminFixorders']
  }
  '/admin/index-metadata': {
    post: operations['postAdminIndexmetadata']
  }
  '/admin/set-community': {
    post: operations['postAdminSetcommunity']
  }
  '/admin/sync-arweave': {
    post: operations['postAdminSyncarweave']
  }
  '/admin/sync-daily-volumes': {
    post: operations['postAdminSyncdailyvolumes']
  }
  '/admin/sync-events': {
    post: operations['postAdminSyncevents']
  }
  '/order/v1': {
    post: operations['postOrderV1']
  }
  '/collections/refresh/v1': {
    post: operations['postCollectionsRefreshV1']
  }
  '/tokens/refresh/v1': {
    post: operations['postTokensRefreshV1']
  }
}

export interface definitions {
  Model1: {
    value: string
    count?: number
  }
  values: definitions['Model1'][]
  Model2: {
    key: string
    kind: 'string' | 'number' | 'date' | 'range'
    values?: definitions['values']
  }
  attributes: definitions['Model2'][]
  getAttributesV1Response: {
    attributes?: definitions['attributes']
  }
  metadata: { [key: string]: unknown }
  sampleImages: string[]
  royalties: {
    recipient?: string
    bps?: number
  }
  lastBuy: {
    value?: number
    timestamp?: number
  }
  token: {
    contract?: string
    tokenId?: string
    name?: string
    image?: string
  }
  floorAsk: {
    id?: string
    price?: number
    maker?: string
    validFrom?: number
    validUntil?: number
    token?: definitions['token']
  }
  topBid: {
    id?: string
    value?: number
    maker?: string
    validFrom?: number
    validUntil?: number
  }
  rank: {
    '1day'?: number
    '7day'?: number
    '30day'?: number
    allTime?: number
  }
  collection: {
    id?: string
    slug?: string
    name?: string
    metadata?: definitions['metadata']
    sampleImages?: definitions['sampleImages']
    tokenCount?: string
    onSaleCount?: string
    primaryContract?: string
    tokenSetId?: string
    royalties?: definitions['royalties']
    lastBuy?: definitions['lastBuy']
    lastSell?: definitions['lastBuy']
    floorAsk?: definitions['floorAsk']
    topBid?: definitions['topBid']
    rank?: definitions['rank']
    volume?: definitions['rank']
  }
  getCollectionV1Response: {
    collection?: definitions['collection']
  }
  Model3: {
    id?: string
    slug?: string
    name?: string
    metadata?: definitions['metadata']
    sampleImages?: definitions['sampleImages']
    tokenCount?: string
    tokenSetId?: string
    royalties?: definitions['royalties']
    floorAskPrice?: number
    topBidValue?: number
    topBidMaker?: string
    rank?: definitions['rank']
    volume?: definitions['rank']
  }
  collections: definitions['Model3'][]
  getCollectionsV1Response: {
    collections?: definitions['collections']
  }
  Model4: {
    id?: string
    slug?: string
    name?: string
    image?: string
    banner?: string
    sampleImages?: definitions['sampleImages']
    tokenCount?: string
    tokenSetId?: string
    primaryContract?: string
    floorAskPrice?: number
    topBidValue?: number
    topBidMaker?: string
    '1dayVolume'?: number
    '7dayVolume'?: number
    '30dayVolume'?: number
    allTimeVolume?: number
    allTimeRank?: number
  }
  Model5: definitions['Model4'][]
  getCollectionsV2Response: {
    collections?: definitions['Model5']
  }
  Model6: {
    kind?: string
    recipient?: string
    bps?: number
  }
  feeBreakdown: definitions['Model6'][]
  Model7: {
    id: string
    kind: string
    side: 'buy' | 'sell'
    fillabilityStatus: string
    approvalStatus: string
    tokenSetId: string
    tokenSetSchemaHash: string
    maker: string
    taker: string
    price: number
    value: number
    validFrom: number
    validUntil: number
    sourceId?: string
    feeBps?: number
    feeBreakdown?: definitions['feeBreakdown']
    expiration: number
    createdAt: string
    updatedAt: string
    rawData?: definitions['metadata']
  }
  orders: definitions['Model7'][]
  getOrdersV1Response: {
    orders?: definitions['orders']
  }
  ownership: {
    tokenCount?: string
    onSaleCount?: string
    floorAskPrice?: number
    topBidValue?: number
    totalBidValue?: number
  }
  Model8: {
    address?: string
    ownership?: definitions['ownership']
  }
  owners: definitions['Model8'][]
  getOwnersV1Response: {
    owners?: definitions['owners']
  }
  Model9: {
    id?: string
    name?: string
  }
  Model10: {
    contract?: string
    tokenId?: string
    name?: string
    image?: string
    collection?: definitions['Model9']
  }
  Model11: {
    token?: definitions['Model10']
    maker?: string
    taker?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  sales: definitions['Model11'][]
  getSalesV1Response: {
    sales?: definitions['sales']
  }
  Model12: {
    token?: definitions['Model10']
    orderSide?: 'ask' | 'bid'
    from?: string
    to?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  Model13: definitions['Model12'][]
  getSalesV2Response: {
    sales?: definitions['Model13']
  }
  Model14: {
    token?: definitions['Model10']
    orderSource?: string
    orderSide?: 'ask' | 'bid'
    from?: string
    to?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  Model15: definitions['Model14'][]
  getSalesV3Response: {
    sales?: definitions['Model15']
    continuation?: string
  }
  Model16: {
    contract?: string
    tokenId?: string
    name?: string
    image?: string
  }
  Model17: {
    id?: string
    price?: number
    maker?: string
    validFrom?: number
    validUntil?: number
    token?: definitions['Model16']
  }
  market: {
    floorAsk?: definitions['Model17']
    topBid?: definitions['topBid']
  }
  stats: {
    tokenCount: number
    onSaleCount: number
    sampleImages?: definitions['sampleImages']
    market?: definitions['market']
  }
  getStatsV1Response: {
    stats?: definitions['stats']
  }
  Model18: {
    contract: string
    tokenId: string
    name?: string
    image?: string
    collection?: definitions['Model9']
    topBidValue?: number
    floorAskPrice?: number
  }
  tokens: definitions['Model18'][]
  getTokensV1Response: {
    tokens?: definitions['tokens']
  }
  getTokensV2Response: {
    tokens?: definitions['tokens']
    continuation?: string
  }
  Model19: {
    id?: string
    name?: string
    image?: string
    slug?: string
  }
  Model20: {
    contract: string
    tokenId: string
    name?: string
    image?: string
    collection?: definitions['Model19']
    topBidValue?: number
    floorAskPrice?: number
  }
  Model21: definitions['Model20'][]
  getTokensV3Response: {
    tokens?: definitions['Model21']
    continuation?: string
  }
  Model22: {
    token?: definitions['Model10']
    from?: string
    to?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  transfers: definitions['Model22'][]
  getTransfersV1Response: {
    transfers?: definitions['transfers']
  }
  Model23: {
    token?: definitions['Model10']
    from?: string
    to?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  Model24: definitions['Model23'][]
  getTransfersV2Response: {
    transfers?: definitions['Model24']
    continuation?: string
  }
  Model25: {
    id?: string
    slug?: string
    name?: string
    metadata?: definitions['metadata']
    sampleImages?: definitions['sampleImages']
    tokenCount?: string
    onSaleCount?: string
    tokenSetId?: string
    royalties?: definitions['royalties']
    lastBuy?: definitions['lastBuy']
    lastSell?: definitions['lastBuy']
    floorAsk?: definitions['floorAsk']
    topBid?: definitions['topBid']
    rank?: definitions['rank']
    volume?: definitions['rank']
  }
  getCollectionDeprecatedV1Response: {
    collection?: definitions['Model25']
  }
  Model26: {
    action: string
    description: string
    status: 'complete' | 'incomplete'
    kind: 'request' | 'signature' | 'transaction'
    data?: definitions['metadata']
  }
  steps: definitions['Model26'][]
  getExecuteBidV1Response: {
    steps?: definitions['steps']
    query?: definitions['metadata']
  }
  Model27: {
    action: string
    description: string
    status: 'complete' | 'incomplete'
    kind: 'request' | 'signature' | 'transaction' | 'confirmation'
    data?: definitions['metadata']
  }
  Model28: definitions['Model27'][]
  getExecuteBuyV1Response: {
    steps?: definitions['Model28']
    quote?: number
    query?: definitions['metadata']
  }
  getExecuteCancelV1Response: {
    steps?: definitions['Model28']
    query?: definitions['metadata']
  }
  Model29: {
    user?: string
    rank: number
    tokenCount: string
    liquidity: number
    maxTopBuyValue: number
    wethBalance: number
  }
  liquidity: definitions['Model29'][]
  getUsersLiquidityV1Response: {
    liquidity?: definitions['liquidity']
  }
  Model30: {
    id: string
    kind: string
    side: 'buy' | 'sell'
    tokenSetId: string
    tokenSetSchemaHash: string
    maker: string
    taker: string
    price: number
    value: number
    validFrom: number
    validUntil: number
    source?: string
    feeBps?: number
    feeBreakdown?: definitions['feeBreakdown']
    expiration: number
    createdAt: string
    updatedAt: string
    metadata?: definitions['metadata']
    rawData?: definitions['metadata']
  }
  Model31: definitions['Model30'][]
  getOrdersAllV1Response: {
    orders?: definitions['Model31']
    continuation?: string
  }
  data: {
    collectionName?: string
    tokenName?: string
    image?: string
  }
  Model32: {
    kind?: 'token'
    data?: definitions['data']
  }
  Model33: {
    id: string
    kind: string
    side: 'buy' | 'sell'
    fillabilityStatus: string
    approvalStatus: string
    tokenSetId: string
    tokenSetSchemaHash: string
    maker: string
    taker: string
    price: number
    value: number
    validFrom: number
    validUntil: number
    metadata?: definitions['Model32']
    source?: definitions['metadata']
    feeBps?: number
    feeBreakdown?: definitions['feeBreakdown']
    expiration: number
    createdAt: string
    updatedAt: string
    rawData?: definitions['metadata']
  }
  Model34: definitions['Model33'][]
  getOrdersAsksV1Response: {
    orders?: definitions['Model34']
    continuation?: string
  }
  Model35: {
    contract?: string
    tokenId?: string
  }
  Model36: {
    token?: definitions['Model35']
    orderSource?: string
    orderSide?: 'ask' | 'bid'
    from?: string
    to?: string
    amount?: string
    txHash?: string
    timestamp?: number
    price?: number
  }
  Model37: definitions['Model36'][]
  getSalesBulkV1Response: {
    sales?: definitions['Model37']
    continuation?: string
  }
  Model38: {
    key?: string
    value?: string
  }
  Model39: definitions['Model38'][]
  Model40: {
    contract: string
    tokenId: string
    name?: string
    description?: string
    image?: string
    collection?: definitions['Model9']
    lastBuy?: definitions['lastBuy']
    lastSell?: definitions['lastBuy']
    owner: string
    attributes?: definitions['Model39']
  }
  Model41: {
    id?: string
    price?: number
    maker?: string
    validFrom?: number
    validUntil?: number
    source?: definitions['metadata']
  }
  Model42: {
    floorAsk?: definitions['Model41']
    topBid?: definitions['topBid']
  }
  Model43: {
    token?: definitions['Model40']
    market?: definitions['Model42']
  }
  Model44: definitions['Model43'][]
  getTokensDetailsV1Response: {
    tokens?: definitions['Model44']
  }
  Model45: {
    contract: string
    tokenId: string
    name?: string
    description?: string
    image?: string
    collection?: definitions['Model9']
    lastBuy?: definitions['lastBuy']
    lastSell?: definitions['lastBuy']
    owner?: string
    attributes?: definitions['Model39']
  }
  Model46: {
    token?: definitions['Model45']
    market?: definitions['Model42']
  }
  Model47: definitions['Model46'][]
  getTokensDetailsV2Response: {
    tokens?: definitions['Model47']
    continuation?: string
  }
  Model48: {
    contract: string
    tokenId: string
    name?: string
    description?: string
    image?: string
    collection?: definitions['Model19']
    lastBuy?: definitions['lastBuy']
    lastSell?: definitions['lastBuy']
    owner?: string
    attributes?: definitions['Model39']
  }
  Model49: {
    token?: definitions['Model48']
    market?: definitions['Model42']
  }
  Model50: definitions['Model49'][]
  getTokensDetailsV3Response: {
    tokens?: definitions['Model50']
    continuation?: string
  }
  getTokensFloorV1Response: {
    tokens?: {
      string?: number
    }
  }
  Model51: {
    value?: number
    quantity?: number
  }
  topBids: definitions['Model51'][]
  getCollectionTopBidsV1Response: {
    topBids?: definitions['topBids']
  }
  Model52: {
    value: number
    timestamp: number
  }
  lastBuys: definitions['Model52'][]
  floorAskPrices: number[]
  Model53: {
    key: string
    value: string
    tokenCount: number
    sampleImages?: definitions['sampleImages']
    lastBuys?: definitions['lastBuys']
    lastSells?: definitions['lastBuys']
    floorAskPrices?: definitions['floorAskPrices']
    topBid?: definitions['topBid']
  }
  Model54: definitions['Model53'][]
  getCollectionAttributesV1Response: {
    attributes?: definitions['Model54']
  }
  Model55: {
    kind?:
      | 'new-order'
      | 'expiry'
      | 'sale'
      | 'cancel'
      | 'balance-change'
      | 'approval-change'
      | 'bootstrap'
      | 'revalidation'
      | 'reprice'
    contract?: string
    tokenId?: string
    orderId?: string
    maker?: string
    price?: number
    previousPrice?: number
    txHash?: string
    txTimestamp?: number
    createdAt?: string
  }
  events: definitions['Model55'][]
  getTokensFloorAskV1Response: {
    events?: definitions['events']
    continuation?: string
  }
  Model56: {
    contract?: string
    tokenId?: string
  }
  Model57: {
    orderId?: string
    maker?: string
    price?: number
    validUntil?: number
    source?: string
  }
  event: {
    id?: number
    kind?:
      | 'new-order'
      | 'expiry'
      | 'sale'
      | 'cancel'
      | 'balance-change'
      | 'approval-change'
      | 'bootstrap'
      | 'revalidation'
      | 'reprice'
    previousPrice?: number
    txHash?: string
    txTimestamp?: number
    createdAt?: string
  }
  Model58: {
    token?: definitions['Model56']
    floorAsk?: definitions['Model57']
    event?: definitions['event']
  }
  Model59: definitions['Model58'][]
  getTokensFloorAskV2Response: {
    events?: definitions['Model59']
    continuation?: string
  }
  Model60: {
    id?: string
    value?: number
  }
  Model61: {
    contract?: string
    tokenId?: string
    name?: string
    image?: string
    collection?: definitions['Model9']
    topBid?: definitions['Model60']
  }
  Model62: {
    tokenCount?: string
    onSaleCount?: string
    floorAskPrice?: number
  }
  Model63: {
    token?: definitions['Model61']
    ownership?: definitions['Model62']
  }
  Model64: definitions['Model63'][]
  getUserTokensV2Response: {
    tokens?: definitions['Model64']
  }
  set: {
    id?: string
    metadata?: definitions['Model32']
    sampleImages?: definitions['sampleImages']
    image?: string
    floorAskPrice?: number
    topBidValue?: number
  }
  primaryOrder: {
    id?: string
    value?: number
    expiration?: number
  }
  Model65: {
    set?: definitions['set']
    primaryOrder?: definitions['primaryOrder']
    totalValid?: number
  }
  positions: definitions['Model65'][]
  getUserPositionsV1Response: {
    positions?: definitions['positions']
  }
  Model66: {
    imageUrl?: string
    discordUrl?: string
    description?: string
    externalUrl?: string
    bannerImageUrl?: string
    twitterUsername?: string
  }
  Model67: {
    id?: string
    name?: string
    metadata?: definitions['Model66']
    floorAskPrice?: number
    topBidValue?: number
  }
  Model68: {
    tokenCount?: string
    onSaleCount?: string
    liquidCount?: string
  }
  Model69: {
    collection?: definitions['Model67']
    ownership?: definitions['Model68']
  }
  Model70: definitions['Model69'][]
  getUserCollectionsV1Response: {
    collections?: definitions['Model70']
  }
  Model71: {
    id?: string
    value?: number
    schema?: definitions['metadata']
  }
  Model72: {
    contract?: string
    tokenId?: string
    name?: string
    image?: string
    collection?: definitions['Model9']
    topBid?: definitions['Model71']
  }
  Model73: {
    tokenCount?: string
    onSaleCount?: string
    floorSellValue?: number
    acquiredAt?: number
  }
  Model74: {
    token?: definitions['Model72']
    ownership?: definitions['Model73']
  }
  Model75: definitions['Model74'][]
  getUserTokensV1Response: {
    tokens?: definitions['Model75']
  }
  Model76: {
    value: string
    count?: number
    tokens?: definitions['sampleImages']
  }
  Model77: definitions['Model76'][]
  Model78: {
    key: string
    kind: 'string' | 'number' | 'date' | 'range'
    values?: definitions['Model77']
  }
  Model79: definitions['Model78'][]
  getAttributesStaticV1Response: {
    attributes?: definitions['Model79']
  }
  getNewApiKeyResponse: {
    key: string
  }
  Model80: {
    fromBlock: number
    toBlock: number
  }
  contracts: string[]
  Model81: {
    kind: 'tokens-floor-sell' | 'tokens-top-buy'
    contracts?: definitions['contracts']
  }
  Model82: {
    by: 'id' | 'maker' | 'contract' | 'all'
    id: string
    maker: string
    contract: string
    kind: 'sell-balance'
  }
  Model83: {
    /** @default rarible */
    method?: 'opensea' | 'rarible'
    collections?: definitions['sampleImages']
  }
  Model84: {
    /** @description Update community for a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
    collection: string
    community: string
  }
  Model85: {
    fromBlock: number
    toBlock: number
  }
  Model86: {
    /** @description If no days are passed, will automatically resync from beginning of time. */
    days?: number
  }
  Model87: {
    eventDataKinds?: definitions['sampleImages']
    fromBlock: number
    toBlock: number
    /** @default true */
    backfill?: boolean
  }
  order: {
    kind: 'opensea' | 'wyvern-v2.3' | '721ex' | 'zeroex-v4'
    data: definitions['metadata']
  }
  attribute: {
    collection: string
    key: string
    value: string
  }
  Model88: {
    order?: definitions['order']
    /** @default reservoir */
    orderbook?: 'reservoir' | 'opensea'
    source?: string
    attribute?: definitions['attribute']
  }
  Model89: {
    kind: 'looks-rare' | '721ex' | 'wyvern-v2.3' | 'zeroex-v4'
    data: definitions['metadata']
  }
  Model90: definitions['Model89'][]
  Model91: {
    orders?: definitions['Model90']
  }
  Model92: {
    /** @description Refresh the given collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:1:2222` */
    collection: string
  }
  postCollectionsRefreshV1Response: {
    message?: string
  }
  Model93: {
    /** @description Refresh the given token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
    token: string
  }
}

export interface operations {
  getAttributesV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getAttributesV1Response']
      }
    }
  }
  /** Get detailed information about a single collection, including real-time stats. */
  getCollectionV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        id?: string
        /** Filter to a particular slug, e.g. `boredapeyachtclub` */
        slug?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionV1Response']
      }
    }
  }
  /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
  getCollectionsV1: {
    parameters: {
      query: {
        /** Filter to a particular community, e.g. `artblocks` */
        community?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Search for collections that match a string, e.g. `bored` */
        name?: string
        /** Filter to a particular slug, e.g. `boredapeyachtclub` */
        slug?: string
        sortBy?: '1DayVolume' | 'allTimeVolume'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionsV1Response']
      }
    }
  }
  /** Useful for getting multiple collections to show in a marketplace, or search for particular collections. */
  getCollectionsV2: {
    parameters: {
      query: {
        /** Filter to a particular community, e.g. `artblocks` */
        community?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Search for collections that match a string, e.g. `bored` */
        name?: string
        /** Filter to a particular slug, e.g. `boredapeyachtclub` */
        slug?: string
        sortBy?: '1DayVolume' | '7DayVolume' | '30DayVolume' | 'allTimeVolume'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionsV2Response']
      }
    }
  }
  /** Access orders with various filters applied. If you need orders created by a single user, use the positions API instead. */
  getOrdersV1: {
    parameters: {
      query: {
        id?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getOrdersV1Response']
      }
    }
  }
  postOrdersV1: {
    parameters: {
      body: {
        body?: definitions['Model91']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  /** Get owners with various filters applied, and a summary of their ownership. Useful for exploring top owners in a collection or attribute. */
  getOwnersV1: {
    parameters: {
      query: {
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getOwnersV1Response']
      }
    }
  }
  /** Get recent sales for a contract or token. */
  getSalesV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getSalesV1Response']
      }
    }
  }
  /** Get recent sales for a contract or token. */
  getSalesV2: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getSalesV2Response']
      }
    }
  }
  /** Note: this API is returns rich metadata, and has advanced filters, so is only designed for small amounts of recent sales. If you want access to sales in bulk, use the `Aggregator > Bulk Sales` API. */
  getSalesV3: {
    parameters: {
      query: {
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        /** Get events after a particular unix timestamp (inclusive) */
        startTimestamp?: number
        /** Get events before a particular unix timestamp (inclusive) */
        endTimestamp?: number
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getSalesV3Response']
      }
    }
  }
  getStatsV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getStatsV1Response']
      }
    }
  }
  /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
  getTokensV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Limit to tokens that are listed for sale */
        onSale?: boolean
        sortBy?: 'tokenId' | 'floorAskPrice' | 'topBidValue'
        sortDirection?: 'asc' | 'desc'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensV1Response']
      }
    }
  }
  /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
  getTokensV2: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensV2Response']
      }
    }
  }
  /** This API is optimized for quickly fetching a list of tokens in a collection, sorted by price, with only the most important information returned. If you need more metadata, use the `tokens/details` API */
  getTokensV3: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to one or more tokens, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        tokens?: string[]
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensV3Response']
      }
    }
  }
  /** Get recent transfers for a contract or token. */
  getTransfersV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTransfersV1Response']
      }
    }
  }
  /** Get recent transfers for a contract or token. */
  getTransfersV2: {
    parameters: {
      query: {
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTransfersV2Response']
      }
    }
  }
  /** Get detailed information about a single collection, including real-time stats. */
  getCollectionsCollectionorslugV1: {
    parameters: {
      path: {
        collectionOrSlug: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionDeprecatedV1Response']
      }
    }
  }
  getExecuteBidV1: {
    parameters: {
      query: {
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        attributeKey?: string
        attributeValue?: string
        maker: string
        weiPrice: string
        orderKind?: 'wyvern-v2.3' | '721ex' | 'zeroex-v4'
        orderbook?: 'reservoir' | 'opensea'
        source?: string
        automatedRoyalties?: boolean
        fee?: string
        feeRecipient?: string
        listingTime?: string
        expirationTime?: string
        salt?: string
        nonce?: string
        v?: number
        r?: string
        s?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getExecuteBidV1Response']
      }
    }
  }
  getExecuteBuyV1: {
    parameters: {
      query: {
        token: string
        taker: string
        quantity?: number
        onlyQuote?: boolean
        maxFeePerGas?: string
        maxPriorityFeePerGas?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getExecuteBuyV1Response']
      }
    }
  }
  getExecuteCancelV1: {
    parameters: {
      query: {
        id: string
        maker: string
        maxFeePerGas?: string
        maxPriorityFeePerGas?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getExecuteCancelV1Response']
      }
    }
  }
  getExecuteListV1: {
    parameters: {
      query: {
        token: string
        maker: string
        weiPrice: string
        orderKind?: '721ex' | 'looks-rare' | 'wyvern-v2.3' | 'zeroex-v4'
        orderbook?: 'opensea' | 'reservoir'
        source?: string
        automatedRoyalties?: boolean
        fee?: string
        feeRecipient?: string
        listingTime?: string
        expirationTime?: string
        salt?: string
        nonce?: string
        v?: number
        r?: string
        s?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getExecuteBidV1Response']
      }
    }
  }
  getExecuteSellV1: {
    parameters: {
      query: {
        token: string
        taker: string
        maxFeePerGas?: string
        maxPriorityFeePerGas?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getExecuteCancelV1Response']
      }
    }
  }
  /** This API calculates the total liquidity created by users, based on the number of tokens they are top bidder for. */
  getLiquidityUsersV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        user?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getUsersLiquidityV1Response']
      }
    }
  }
  /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
  getOrdersAllV1: {
    parameters: {
      query: {
        contract?: string
        source?: string
        side?: 'sell' | 'buy'
        includeMetadata?: boolean
        includeRawData?: boolean
        continuation?: string
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getOrdersAllV1Response']
      }
    }
  }
  /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
  getOrdersAsksV1: {
    parameters: {
      query: {
        /** Filter to a token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular user, e.g. `0x4d04eb67a2d1e01c71fad0366e0c200207a75487` */
        maker?: string
        /**
         * `active` = currently valid, `inactive` = temporarily invalid, `expired` = permanently invalid
         *
         * Available when filtering by maker, otherwise only valid orders will be returned
         */
        status?: 'active' | 'inactive' | 'expired'
        sortBy?: 'price' | 'createdAt'
        continuation?: string
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getOrdersAsksV1Response']
      }
    }
  }
  /** This API is designed for efficiently ingesting large volumes of orders, for external processing */
  getOrdersBidsV1: {
    parameters: {
      query: {
        /** Filter to a token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular user, e.g. `0x4d04eb67a2d1e01c71fad0366e0c200207a75487` */
        maker?: string
        /**
         * `active` = currently valid, `inactive` = temporarily invalid, `expired` = permanently invalid
         *
         * Available when filtering by maker, otherwise only valid orders will be returned
         */
        status?: 'active' | 'inactive' | 'expired'
        sortBy?: 'price' | 'createdAt'
        continuation?: string
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getOrdersAsksV1Response']
      }
    }
  }
  getOrdersExecutedV1: {
    parameters: {
      query: {
        id: string
        checkRecentEvents?: boolean
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  /** Note: this API is optimized for bulk access, and offers minimal filters/metadata. If you need more flexibility, try the `NFT API > Sales` endpoint */
  getSalesBulkV1: {
    parameters: {
      query: {
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Get events after a particular unix timestamp (inclusive) */
        startTimestamp?: number
        /** Get events before a particular unix timestamp (inclusive) */
        endTimestamp?: number
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getSalesBulkV1Response']
      }
    }
  }
  /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
  getTokensDetailsV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Limit to tokens that are listed for sale */
        onSale?: boolean
        sortBy?: 'tokenId' | 'floorAskPrice' | 'topBidValue'
        sortDirection?: 'asc' | 'desc'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensDetailsV1Response']
      }
    }
  }
  /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
  getTokensDetailsV2: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        /** Filter to a particular source, e.g. `0x5b3256965e7c3cf26e11fcaf296dfc8807c01073` */
        source?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensDetailsV2Response']
      }
    }
  }
  /** Get a list of tokens with full metadata. This is useful for showing a single token page, or scenarios that require more metadata. If you don't need this metadata, you should use the <a href='#/tokens/getTokensV1'>tokens</a> API, which is much faster. */
  getTokensDetailsV3: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        /** Filter to one or more tokens, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        tokens?: string[]
        /** Filter to a particular set, e.g. `contract:0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        tokenSetId?: string
        /** Filter to a particular attribute, e.g. `attributes[Type]=Original` */
        attributes?: string
        /** Filter to a particular source, e.g. `0x5b3256965e7c3cf26e11fcaf296dfc8807c01073` */
        source?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        limit?: number
        continuation?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensDetailsV3Response']
      }
    }
  }
  /** This API will return the best price of every token in a collection that is currently on sale */
  getTokensFloorV1: {
    parameters: {
      query: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensFloorV1Response']
      }
    }
  }
  /** When users are placing collection or trait bids, this API can be used to show them where the bid is in the context of other bids, and how many tokens it will be the top bid for. */
  getCollectionsCollectionTopbidsV1: {
    parameters: {
      path: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionTopBidsV1Response']
      }
    }
  }
  getCollectionsCollectionAttributesV1: {
    parameters: {
      path: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string
      }
      query: {
        attributeKey?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionAttributesV1Response']
      }
    }
  }
  /**
   * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
   *
   * There are multiple event types, which describe what caused the change in price:
   *
   * - `new-order` > new listing at a lower price
   *
   * - `expiry` > the previous best listing expired
   *
   * - `sale` > the previous best listing was filled
   *
   * - `cancel` > the previous best listing was cancelled
   *
   * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
   *
   * - `approval-change` > the best listing was invalidated due to revoked approval
   *
   * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
   *
   * - `bootstrap` > initial loading of data, so that all tokens have a price associated
   *
   * Some considerations to keep in mind
   *
   * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
   *
   * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
   */
  getEventsTokensFlooraskV1: {
    parameters: {
      query: {
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Get events after a particular unix timestamp (inclusive) */
        startTimestamp?: number
        /** Get events before a particular unix timestamp (inclusive) */
        endTimestamp?: number
        sortDirection?: 'asc' | 'desc'
        continuation?: string
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensFloorAskV1Response']
      }
    }
  }
  /**
   * Every time the best price of a token changes (i.e. the 'floor ask'), an event is generated. This API is designed to be polled at high frequency, in order to keep an external system in sync with accurate prices for any token.
   *
   * There are multiple event types, which describe what caused the change in price:
   *
   * - `new-order` > new listing at a lower price
   *
   * - `expiry` > the previous best listing expired
   *
   * - `sale` > the previous best listing was filled
   *
   * - `cancel` > the previous best listing was cancelled
   *
   * - `balance-change` > the best listing was invalidated due to no longer owning the NFT
   *
   * - `approval-change` > the best listing was invalidated due to revoked approval
   *
   * - `revalidation` > manual revalidation of orders (e.g. after a bug fixed)
   *
   * - `bootstrap` > initial loading of data, so that all tokens have a price associated
   *
   * Some considerations to keep in mind
   *
   * - Due to the complex nature of monitoring off-chain liquidity across multiple marketplaces, including dealing with block re-orgs, events should be considered 'relative' to the perspective of the indexer, ie _when they were discovered_, rather than _when they happened_. A more deterministic historical record of price changes is in development, but in the meantime, this method is sufficent for keeping an external system in sync with the best available prices.
   *
   * - Events are only generated if the best price changes. So if a new order or sale happens without changing the best price, no event is generated. This is more common with 1155 tokens, which have multiple owners and more depth. For this reason, if you need sales data, use the Sales API.
   */
  getEventsTokensFlooraskV2: {
    parameters: {
      query: {
        contract?: string
        /** Filter to a particular token, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63:123` */
        token?: string
        /** Get events after a particular unix timestamp (inclusive) */
        startTimestamp?: number
        /** Get events before a particular unix timestamp (inclusive) */
        endTimestamp?: number
        sortDirection?: 'asc' | 'desc'
        continuation?: string
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getTokensFloorAskV2Response']
      }
    }
  }
  /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
  getUsersUserTokensV2: {
    parameters: {
      path: {
        /** Wallet to see results for e.g. `0xf296178d553c8ec21a2fbd2c5dda8ca9ac905a00` */
        user: string
      }
      query: {
        /** Filter to a particular community, e.g. `artblocks` */
        community?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getUserTokensV2Response']
      }
    }
  }
  /** Get aggregate user liquidity, grouped by collection. Useful for showing a summary of liquidity being provided (orders made). */
  getUsersUserPositionsV1: {
    parameters: {
      path: {
        /** Wallet to see results for e.g. `0xf296178d553c8ec21a2fbd2c5dda8ca9ac905a00` */
        user: string
      }
      query: {
        side: 'buy' | 'sell'
        status: 'valid' | 'invalid'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getUserPositionsV1Response']
      }
    }
  }
  /** Get aggregate stats for a user, grouped by collection. Useful for showing total portfolio information. */
  getUsersUserCollectionsV1: {
    parameters: {
      path: {
        /** Wallet to see results for e.g. `0xf296178d553c8ec21a2fbd2c5dda8ca9ac905a00` */
        user: string
      }
      query: {
        /** Filter to a particular community, e.g. `artblocks` */
        community?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getUserCollectionsV1Response']
      }
    }
  }
  /** Get tokens held by a user, along with ownership information such as associated orders and date acquired. */
  getUsersUserTokensV1: {
    parameters: {
      path: {
        user: string
      }
      query: {
        /** Filter to a particular community, e.g. `artblocks` */
        community?: string
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection?: string
        /** Filter to a particular contract, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        contract?: string
        hasOffer?: boolean
        sortBy?: 'topBuyValue'
        sortDirection?: 'asc' | 'desc'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getUserTokensV1Response']
      }
    }
  }
  getCollectionsCollectionAttributesAllV1: {
    parameters: {
      path: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getAttributesV1Response']
      }
    }
  }
  getCollectionsCollectionAttributesStaticV1: {
    parameters: {
      path: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getAttributesStaticV1Response']
      }
    }
  }
  getCollectionsCollectionAttributesExploreV1: {
    parameters: {
      path: {
        /** Filter to a particular collection, e.g. `0x8d04a8c79ceb0889bdd12acdf3fa9d207ed3ff63` */
        collection: string
      }
      query: {
        /** Filter to a particular attribute key, e.g. `Composition` */
        attributeKey?: string
        sortBy?: 'floorAskPrice' | 'topBidValue'
        offset?: number
        limit?: number
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getCollectionAttributesV1Response']
      }
    }
  }
  /**
   * The optional API key can be used in every route, by setting it as a request header **x-api-key**.
   *
   * <a href='https://reservoirprotocol.github.io/docs/api/hosted-api'>Learn more</a> about API Keys and Rate Limiting
   */
  postApikeys: {
    parameters: {
      formData: {
        /** The name of your app */
        appName: string
        /** An e-mail address where you can be reached, in case of issues, to avoid service disruption */
        email: string
        /** The website of your project */
        website: string
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['getNewApiKeyResponse']
      }
    }
  }
  postAdminFixblocks: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model80']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminFixcache: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model81']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminFixorders: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model82']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminIndexmetadata: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model83']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminSetcommunity: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model84']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminSyncarweave: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model85']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminSyncdailyvolumes: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model86']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postAdminSyncevents: {
    parameters: {
      header: {
        'x-admin-api-key': string
      }
      body: {
        body?: definitions['Model87']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postOrderV1: {
    parameters: {
      body: {
        body?: definitions['Model88']
      }
    }
    responses: {
      /** Successful */
      default: {
        schema: string
      }
    }
  }
  postCollectionsRefreshV1: {
    parameters: {
      body: {
        body?: definitions['Model92']
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['postCollectionsRefreshV1Response']
      }
    }
  }
  postTokensRefreshV1: {
    parameters: {
      body: {
        body?: definitions['Model93']
      }
    }
    responses: {
      /** Successful */
      200: {
        schema: definitions['postCollectionsRefreshV1Response']
      }
    }
  }
}

export interface external {}
